#!/usr/local/bin/perl5.8.0 -w

use OtterDefs;
use strict;

use CGI;

use HTTPD::Authen;
use Bio::Otter::Version;
use Bio::Otter::ServerSide qw(error_exit
                              send_response
                              set_nph);

$|             = 1;
my $DEBUG      = 0;
my $ALLOW_ALL  = 0;
my $ERROR_AUTH = q`unknown user or incorrect password`;

my $q      = new CGI;
set_nph($q);
my %params = $q->Vars;
my $user   = $params{'author'} || '**NOT Using Authorization**';


my $groupAd;

if($ENV{AUTHUSERFILE} && $ENV{AUTHGROUPFILE}){
    ($groupAd,$user) = check_authorisation();
}else{
    $ALLOW_ALL = 1;
}

# This is a check so that $groupAd->exists won't die if
# ALLOW_ALL is false when no authentication was passed
error_exit($q, $ERROR_AUTH) unless $groupAd || $ALLOW_ALL;

# find the ones they're allowed
my @allowed_to_see = ();

foreach my $dataset (keys %$OTTER_SPECIES) {
  next if ($dataset =~ /defaults/);
  print STDERR "Testing user '$user' in dataset '$dataset'" if $DEBUG;
  # This "next unless" uses perl's clever "or" checking where it 
  # won't bother checking the second for truth if the first is true.
  next unless $ALLOW_ALL || $groupAd->exists($dataset, $user);
  print STDERR "Allowing user '$user' access to dataset '$dataset'" if $DEBUG;
  push(@allowed_to_see, $dataset);
}


# I'd like to use xml::writer here, but it won't do output to string
# Also it's probably a bit heavyweight just to concatenate a few strings together.
my $xml = qq`<?xml version="1.0" encoding="UTF-8"?>\n`;
$xml   .= qq`<otter schemaVersion="$SCHEMA_VERSION" xmlVersion="$XML_VERSION">\n`;
$xml   .= qq`  <datasets>\n`;
# print the one's user is allowed to see.
foreach my $dataset(@allowed_to_see){
    $xml .= qq`    <dataset name="$dataset">\n`;
    foreach my $key (keys %{$OTTER_SPECIES->{$dataset}}) {
        $xml .= qq`      <` . lc $key . qq`>`;
        $xml .= $OTTER_SPECIES->{$dataset}->{$key};
        $xml .= qq`</` . lc $key . qq`>\n`;
    }
    $xml .= qq`    </dataset>\n`;
}
$xml .= qq`  </datasets>\n`;
$xml .= qq`</otter>\n`;


send_response($q, $xml);

#End main














sub check_authorisation{
    my ($groupAdminObj, $authinfo, $authen);

    $authinfo = $ENV{'HTTP_AUTHORIZATION'} || 'Basic xxxxxxx';
    $authen = HTTPD::Authen->new(DB     => $ENV{AUTHUSERFILE},
                                 DBType => 'Text',
                                 Server => 'Apache');
    print STDERR "AUTH was '$authinfo'" if $DEBUG;

    my $authtype      = $authen->type($authinfo);
    my ($user, $pass) = ('ERROR') x 2;
    ($user, $pass)    = $authtype->parse($authinfo);

    print STDERR "Got info ['$user', '$pass']" if $DEBUG;

    if( my $ok = $authen->check($user, $pass) ){
        print STDERR "user '$user', was AUTHENTICATED" if $DEBUG;
        $groupAdminObj = $authen->{USER}->group($user);
        $groupAdminObj->db($ENV{'AUTHGROUPFILE'});
        if($DEBUG){
            # this gets all the groups in the .htgroups file
            foreach my $groupname($groupAdminObj->list()){
                if($groupAdminObj->exists($groupname, $user)){
                    print STDERR "User: '$user' is part of group: '$groupname'";
                }else{
                    print STDERR "User: '$user' is *NOT* part of group: '$groupname'";
                }
            }
        }
    }else{
        print STDERR "user was NOT AUTHENTICATED" if $DEBUG;
        error_exit($q, $ERROR_AUTH);
    }
    return $groupAdminObj, $user;

}

=pod

=head1 get_datasets

=head1 DESCRIPTION

Returns a list of datasets to the Client.
Will only return the list the user has access to see
if the server has been setup (see ../../conf/README.user.pod).

=cut
