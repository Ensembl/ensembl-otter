#!/usr/local/bin/perl -w

### HUGO_gene_name_to_otter

use strict;
use Bio::Otter::Lace::Defaults;

{
    my ($dataset_name);

    Bio::Otter::Lace::Defaults::do_getopt(
        'dataset=s' => \$dataset_name,
      );
    Bio::Otter::Lace::Defaults::show_help() unless $dataset_name;

    my $hugo_data = parse_hugo_input();

    # Client communicates with otter HTTP server
    my $cl = Bio::Otter::Lace::Defaults::make_Client();

    # DataSet interacts directly with an otter database
    my $ds = $cl->get_DataSet_by_name($dataset_name);

    my $otter_dba = $ds->get_cached_DBAdaptor;

    $otter_dba->begin_work;
    eval{
        update_otter($otter_dba, $hugo_data);
    };
    if ($@) {
        $otter_dba->rollback;
        die $@, "\nNo changes saved to otter db\n";
    } else {
        #$otter_dba->rollback;
        $otter_dba->commit;
    }
}

sub update_otter {
    my ($otter_dba, $hugo_data) = @_;
    
    my $gene_aptr = $otter_dba->get_GeneAdaptor;
    foreach my $hugo (@$hugo_data) {
        my $gene_id = current_gene_id_for_transcript($otter_dba, $hugo->{'otter_tsct_id'})
            or die "Can't find current gene ID for transcript '$hugo->{otter_tsct_id}'";
        my $gene = $gene_aptr->fetch_by_dbID($gene_id);
        if (unexpected_gene_type($gene)) {
            printf STDERR "Unexpected gene type '%s' in gene '%s' from HUGO: %s\n",
                $gene->type, $gene->stable_id, $hugo->{'original_line'};
            next;
        }
        update_otter_gene($otter_dba, $hugo, $gene);
    }
}

sub unexpected_gene_type {
    my( $gene ) = @_;
    
    my $type = $gene->type;
    if ($type =~ /:/ or $type eq 'obsolete') {
        return 1;
    } else {
        return 0;
    }
}

sub update_otter_gene {
    my ($otter_dba, $hugo, $gene) = @_;

    print STDERR "Gene type = '", $gene->type, "' hugo = '$hugo->{category}'";
    update_gene_known($otter_dba, $hugo->{'category'},     $gene);
    print STDERR " after = '", $gene->type, "'\n";

    # We don't want to alter any data for Pseudogenes.    
    return if $gene->type =~ /pseudo/i;

    update_gene_name( $otter_dba, $hugo->{'locus_symbol'}, $gene);
    update_gene_description($otter_dba, $hugo->{'locus_description'}, $gene);
}

{
    my( $sth, $syn_sth );

    sub update_gene_name {
        my ($otter_dba, $name, $gene) = @_;

        my $current_name = $gene->gene_info->name->name;
        if (! $name or $current_name eq $name) {
            return;
        }
        $sth ||= $otter_dba->prepare(q{
            UPDATE gene_name
            SET name = ?
            WHERE gene_info_id = ?
            });
        $sth->execute($name, $gene->gene_info->dbID);
        
        my $found = 0;
        foreach my $syn ($gene->gene_info->synonym) {
            if ($syn->name eq $current_name) {
                $found = 1;
                last;   # Current name already a synonym!
            }
        }
        unless ($found) {
            $syn_sth ||= $otter_dba->prepare(q{
                INSERT gene_synonym(name
                      , gene_info_id)
                VALUES (?,?)
                });
            $syn_sth->execute($current_name, $gene->gene_info->dbID);
        }
    }
}

{
    my ($sth, $type_sth);

    sub update_gene_known {
        my ($otter_dba, $category, $gene) = @_;

        my $known = lc($category) eq 'known' ? 1 : 0;
        my $type = Bio::Otter::Converter::gene_type_from_transcript_set($gene->get_all_Transcripts, $known);

        unless ($known == $gene->gene_info->known_flag) {
            $sth ||= $otter_dba->prepare(q{
                UPDATE gene_info
                SET is_known = ?
                WHERE gene_info_id = ?
                });
            $sth->execute($known, $gene->gene_info->dbID);
            $gene->gene_info->known_flag($known);
        }
        unless ($type eq $gene->type) {
            $type_sth ||= $otter_dba->prepare(q{
                UPDATE gene
                SET type = ?
                WHERE gene_id = ?
                });
            $sth->execute($type, $gene->dbID);
            $gene->type($type);
        }
    }
}

{
    my $sth;

    sub update_gene_description {
        my ($otter_dba, $desc, $gene) = @_;

        my $current_desc = $gene->description || '';
        if (! $desc or $current_desc eq $desc) {
            return;
        }
        $sth ||= $otter_dba->prepare(q{
            REPLACE gene_description(description
                  , gene_id)
            VALUES (?,?)
            });
        $sth->execute($desc, $gene->dbID);
    }
}

{
    my $sth;

    sub current_gene_id_for_transcript {
        my( $dba, $tsct_id ) = @_;

        $sth ||= $dba->prepare(q{
            SELECT t.gene_id
            FROM transcript_stable_id tsid
              , transcript t
            WHERE tsid.transcript_id = t.transcript_id
              AND tsid.stable_id = ?
            ORDER BY tsid.version DESC LIMIT 1
            });
        $sth->execute($tsct_id);
        
        my ($gene_id) = $sth->fetchrow;
        return $gene_id;
    }
}

sub parse_hugo_input {
    my @field_names = qw{
      locus_symbol locus_description hgnc_id category otter_tsct_id locus_type notes
    };

    my $hugo_data = [];
    while (<>) {
        next if /^\s*#/;                # Allow for hashed comment lines
        next if /^\s*$/;                # Skip empty lines
        next if /^Approved Symbol/;     # The header
        chomp;
        my @fields = split /\t/, $_;    # Fields should be tab separated
        my $original_line = $_;

        # There's something wrong with the line if we
        # don't have the right number of fields.
        unless (@fields == @field_names) {
            die 'Bad line: ', fmt_list(@fields);
        }

        my $parsed_line = {};
        for (my $i = 0 ; $i < @field_names ; $i++) {
            my $field_name = $field_names[$i];
            my $data = $fields[$i];
            $data =~ s/(^\s+)|(\s+$)//g;    # Trim leading and trailing whitespace
            unless ($data) {
                die 'Bad data element: ', fmt_list(@fields);
            }
            next if $data eq 'NULL';
            $parsed_line->{$field_name} = $data;
        }
        $parsed_line->{'original_line'} = $original_line;
        push(@$hugo_data, $parsed_line);
    }
    return $hugo_data;
}

sub fmt_list {
    return join(', ', map "'$_'", @_);
}

__END__

=head1 NAME - HUGO_gene_name_to_otter

=head1 AUTHOR

James Gilbert B<email> jgrg@sanger.ac.uk

