#!/usr/local/bin/perl -w

=head1 NAME

embl_to_otter_ensembl

=head1 SYNOPSIS
 
embl_to_otter_ensembl [options] EMBL_Entries_File

=head1 DESCRIPTION

This script reads the EMBL Entries file supplied
and using this as the source for all sequence 
information populates the B<Otter> and B<Pipeline>
databases.

A B<Sequence Set> is then created of the sequences 
in the order they were specified in the EMBL file.

The EMBL file I<MUST> only contain B<DNA> sequences 
from a single species which must match the species
for which the dataset resolves.

=head1 USEAGE

embl_to_otter_ensembl [options] -embl EMBL_Entries_File

Where options are:

 option       default   comment
 ----------------------------------
 -dataset     human     dataset name as seen in Dataset Chooser window of Otterlace.
 -chr                   the chromosome on which the sequences reside.
 -name                  a name for the set which will be created.
 -description           a description for the set.  Enclose in quotes ['].
 -priority    5         the priority assigned for analysis [1-10]
 -species     9606      taxon id of the species the sequences belong to.


example:

./embl_to_otter_ensembl -dataset human -chr X -name 'example' -desc 'just an example' -embl ~/example.embl

./embl_fetch_set AL133226.16 | ./embl_to_otter_ensembl -dataset human -chr X -name 'example' -desc 'just an example'

=cut

use strict;

# for benchmarking
use Time::HiRes qw(gettimeofday tv_interval);

use Getopt::Long;
use Bio::SeqIO;
use Bio::EnsEMBL::Analysis;
use Bio::EnsEMBL::Clone;
use Bio::EnsEMBL::RawContig;
use Bio::EnsEMBL::Pipeline::DBSQL::DBAdaptor;
use Bio::EnsEMBL::Chromosome;

use Bio::EnsEMBL::DBSQL::DBAdaptor;
use Bio::EnsEMBL::Clone;
use Bio::Otter::Lace::CloneSequence;
use Bio::Otter::Lace::PipelineDB;
use Bio::Otter::Lace::Defaults;
use Hum::EMBL;
use Data::Dumper;

use Mail::Mailer;

my $DOMAIN = 'sanger.ac.uk';
my $EMAIL = 'anacode@'.$DOMAIN;
my $DEBUG = 0;
my $embl_entries = {};

# this script will read STDIN only if piped to
my $PIPED_TO = (-p STDIN ? 1 : 0);

{
    my $t0 = [gettimeofday];
    
    # some important variables (and some less inportant ones that look neater up here) 
    my $INPUT_TYPE;           # AGP or LIST
    my $embl_file ;           # the file containing the EMBL entries
    my $pipe_analysis ;       # analysis adaptor for the pipeline db
    my $end_coord;            # max(chr_end) 
    my $clone_sequence_list;  # the clone sequence list built for the sequence set
    
    ## next set of variables are overwritten if a command line option is specified
    my $analysis_priority = 5; # hold the deafulat value for the analysis priority
    my $author            = (getpwuid($<))[0];
    my $description       = undef;   # "This is a default description, created by $author";
    my $dataset_name      = 'human'; # dataset to get from otter server
    my $chromosome_name   = undef;
    my $set_name          = undef;
    my $delete            = undef;
    my $submit_contig     = 'SubmitContig';
    my $superctg_ori      = 1; # default value for just now. - true value will be added by a different script
    my $help              = 0;
    my $molecule_type     = "genomic DNA";

    #---------------------------------------------------------------------------
    Bio::Otter::Lace::Defaults::do_getopt(
        'dataset=s'     => \$dataset_name,
	'h|help'        => \$help,
        'description=s' => \$description,
        'priority=i'    => \$analysis_priority ,
        'chromosome=s'  => \$chromosome_name, 
        'set|name=s'    => \$set_name,
	'debug'         => \$DEBUG,
        'embl=s'        => \$embl_file,
        );
    useage() if $help;
#    $embl_file            = $ARGV[0]; # takes the remaining argument as the filename to be read

    # some options checking to make sure there's some sanity
    die "No EMBL file given. Please give a file name.\n"               if (! defined $embl_file) && (! $PIPED_TO);
    die "Please specify a description using -desc 'interesting'\n"     if (! defined $description);
    die "Please specify a set name using -set 'set name'\n"            if (! defined $set_name);
    die "Please specify a chromosome name using -chr 'name'\n"         if (! defined $chromosome_name);
    warn "Chr names containing 'chr' are illegal. Removing\n"          if ($chromosome_name =~ /chr/i);

    $chromosome_name =~ s/chr//gi;


    # make otter client and connect to database
    my $cl       = Bio::Otter::Lace::Defaults::make_Client();
    my $ds       = $cl->get_DataSet_by_name($dataset_name);
    my $otter_db = $ds->get_cached_DBAdaptor;

    # get species info
    my $species  = $ds->taxon();

    # parse the EMBL input file, list of EMBL Entries separated by //
    my $order = [];
    ($order, $embl_entries)  = check_embl_input($embl_file, $species, $molecule_type);

    # Make a connection to the pipeline database
    my $pipeline_db = Bio::Otter::Lace::PipelineDB::get_pipeline_DBAdaptor($otter_db);
    $pipeline_db->db_handle->{'PrintError'} = 0; # turn off error writing for this db handle
    # Get SubmitContig analysis object for priming the pipeline
    $pipe_analysis = $pipeline_db->get_AnalysisAdaptor;
    my $ana_obj    = $pipe_analysis->fetch_by_logic_name($submit_contig);
    unless ($ana_obj) {
         $ana_obj = new Bio::EnsEMBL::Pipeline::Analysis(-LOGIC_NAME     => $submit_contig,
							 -INPUT_ID_TYPE  => 'CONTIG',
							 );
         $pipe_analysis->store($ana_obj);
    }

    #------------------------- read input file -----------------------------------------    
#    open(my $fh, "$agp_file") or die "Can't read '$agp_file' : $!";

    # make an empty sequence set to start with
    my $SequenceSet = Bio::Otter::Lace::SequenceSet->new;
    $SequenceSet->name($set_name);             # set name from command line
    $SequenceSet->dataset_name($dataset_name); # data set from command line
    $SequenceSet->description($description);   # description from command line

    
    $INPUT_TYPE = "EMBL";

    # Chr prefix causes problems for Apollo
#    $chromosome_name ||= $agp_chr_name;
    
    $chromosome_name =~ s/^chr//i; # recheck chromosome name as it may have changed [AGP]

    my $otter_chromosome = get_chromosome($otter_db    , $chromosome_name);
    my $pipe_chromosome  = get_chromosome($pipeline_db , $chromosome_name);
    
    $end_coord = $ds->tmpstore_meta_info_for_SequenceSet($SequenceSet, [$otter_db, $pipeline_db]);

    foreach my $acc_ver(@$order){
 	my ($input_type, 
 	    $super_contig_name,
 	    $chr_start,
 	    $chr_end,
 	    $n,
 	    $type,
 	    $ctg_start,
 	    $ctg_end,
 	    $ctg_ori);

 	if($INPUT_TYPE eq 'EMBL'){
            my $seq     = $embl_entries->{$acc_ver};
	    my $seq_length;
	    if ($seq) {
		$seq_length = $seq->length;
		print STDERR "Sequence: $acc_ver, length: $seq_length\n";
	    }else{
		die "Can't fetch sequence '$acc_ver'\n";
	    }
	    # $super_contig_name/$chromosome_name should be available from the command line 
	    # if we have a clone list as input (or we would have died earlier)
            $super_contig_name = $chromosome_name;
            $n         = 5;    # does this get used for anything? - don't think so
            $type      = 'F';        
            $ctg_ori   = '+';
            $chr_start = $end_coord + 10001;
            $chr_end   = ($chr_start + $seq_length - 1);
            $end_coord = $chr_end; # so that it is in a suitable position for next time     
            $ctg_start = 1;
            $ctg_end   = $seq_length; # $ctg_end = $ctg_start + length - 1 ; as we are starting at 1 just use length

	}else{
            die "You should have input type EMBL not <$INPUT_TYPE>\n";
	}

	# translate orientation to integer
        if ($ctg_ori eq '-') {
            $ctg_ori = -1;
        }
        elsif ($ctg_ori eq '+') {
            $ctg_ori = 1;
        }
	else {
            die "Invalid orientation '$ctg_ori'\n";
        }
	#split into accesion number and version number 
        my ($acc, $sv) = $acc_ver =~ /^(.+)\.(\d+)$/;
        die "Can't parse '$acc_ver' into accession and sv\n" unless $acc and $sv;
        
        # make a CloneSequence for each line
	my $CloneSequence = Bio::Otter::Lace::CloneSequence->new();
 
	$CloneSequence->accession($acc);
	$CloneSequence->sv($sv);
	# $CloneSequence->clone_name();
	# $CloneSequence->length();
	$CloneSequence->chromosome($otter_chromosome->dbID);
	$CloneSequence->pipeline_chromosome($pipe_chromosome->dbID);
	$CloneSequence->chr_start($chr_start);
	$CloneSequence->chr_end($chr_end);
	$CloneSequence->super_contig_name($super_contig_name);
	# $CloneSequence->contig_id();
	# $CloneSequence->contig_name();
	$CloneSequence->contig_start($ctg_start);
	$CloneSequence->contig_end($ctg_end);
	$CloneSequence->contig_strand($ctg_ori);

        warn "adding $acc to list";
        # add CloneSequence to the SequenceSet (temporary array)
	push (@{$clone_sequence_list}, $CloneSequence);  

    }
    # Should now have a sequence set


    # Store the sequence set, returning a list of pipeline contigs
    $SequenceSet->CloneSequence_list($clone_sequence_list);
#    my $pipe_contigs = $ds->store_SequenceSet($SequenceSet, \&pfetch_acc_sv, $INPUT_TYPE eq 'LIST');
    my $pipe_contigs = $ds->store_SequenceSet($SequenceSet, \&fake_seqfetcher, 1);
    # print STDERR join("\n", map { $_->name } @$pipe_contigs);

    # prime the pipeline database with SubmitContig analysis
    store_input_id_analysis($pipe_contigs, $pipeline_db, $ana_obj);

    # update chromosome lengths
    update_chromosome_length($pipeline_db, $pipe_chromosome);
    update_chromosome_length($otter_db, $otter_chromosome);

    # benchmarking 

    my $elapsed = tv_interval ( $t0, [gettimeofday]);
    print STDERR "code took: $elapsed seconds\n" if $DEBUG;

    # check for pipeline.lock
    # mail me if not running
    unless($pipeline_db->pipeline_lock){
	
	my $subj = 'User Submission of Clones for Analysis ';
	$subj   .= '**JUST A TEST**' if $DEBUG;
	my $mess = "$author submitted set <$set_name> in dataset <$dataset_name>.";
	$mess   .= "\nIt contains " . scalar(@{$clone_sequence_list}) . " clone(s) on Chromosome <$chromosome_name>.";
	$mess   .= "\n";
	$mess   .= "\nDescription : <$description>";
	$mess   .= "\nPriority    : <$analysis_priority>";
	$mess   .= "\n";
	$mess   .= "\nPlease start the pipeline running on this set.";
	$mess   .= "\n";
	$mess   .= "\n" . join(" ", (-dbhost, $pipeline_db->host,
				     -dbport, $pipeline_db->port,
				     -dbname, $pipeline_db->dbname,
				     -dbuser, $pipeline_db->username,
				     -dbpass, $pipeline_db->password || undef));

	warn "Sending Mail to $EMAIL\n";
	my $mail = Mail::Mailer->new('smtp', Server => 'mail.sanger.ac.uk');
	my $mfh = $mail->open({
	    From    => "$author\@$DOMAIN",
	    To      => [ $EMAIL ],
	    Subject => $subj,
        });
	print $mfh $mess;
	$mfh->close;

    }
    
}

#------------------end of main script ------------------------------------------
#                     Subroutines
#-------------------------------------------------------------------------------
#


sub fake_seqfetcher{
    my ($id) = @_;
    my $seq  = $embl_entries->{$id}  || die "ERROR: couldn't find $id in hash";
    return $seq;
}

sub check_embl_input{
    my ($infile, $sp, $mol) = @_;
    warn "Checking file <".( $PIPED_TO ? 'STDIN' : $infile)."> for species <$sp> and molecule <$mol>\n" if $DEBUG;

    my $parser = Hum::EMBL->new;
    my $order  = []; # remembers the order of the clones in the file
    my $bio_seq_objs = {};
    my $fh;

    # open the file or return an empty hash
    if($infile){
	open ($fh, $infile) or return $bio_seq_objs;
    }elsif($PIPED_TO){
	$fh = \*STDIN;
    }else{
	return $bio_seq_objs;
    }

    while (my $entry = $parser->parse($fh)){
	my $error    = 0;
	my $id_line  = $entry->ID;
	my $acc      = $entry->AC->primary;
	my $molecule = $id_line->molecule;
	my $seq_ver  = $entry->SV->version;
	my $acc_sv   = $acc . ".". $seq_ver;
	my $taxon_id = undef;

	FEAT: foreach my $ft ($entry->FT){
	    next FEAT unless $ft->key eq 'source';
	    QUAL: foreach my $key($ft->qualifiers){
		my ($ident, $value) = ($key->name, $key->value);
		next QUAL unless $ident eq 'db_xref';
		if($value =~ /taxon:(\d+)/){
		    $taxon_id = $1;
		    last FEAT;
		}
	    }
	}
	
	warn(sprintf("Acc <%s>, molecule <%s>, species <%s>\n", $acc, $molecule, $taxon_id)) if $DEBUG;

	# SANITY
	$error = 1 unless $molecule;
	$error = 1 unless $molecule =~ /$mol/;
	$error = 1 unless $taxon_id;
	$error = 1 unless $taxon_id eq $sp;

	if($error){ # don't add if insane
	    die(
		 sprintf("*****************************************************" .
			 "\nEntry %s isn't good. Not written." .
                         "\nI wanted molecule <%s>, but got <%s>" . 
			 "\nand species taxon ID <%s>, but got <%s>" . 
			 "\nPlease email %s if you need further info." .
			 "\n*****************************************************\n",
			 $acc_sv, $mol, $molecule, $sp, $taxon_id, $EMAIL)
		 );
	    next;
	}

	# everything's good
	my $bio_seq = $entry->bio_seq();
	my $seq_len = $bio_seq->length();
	warn "Adding $bio_seq $acc_sv has length $seq_len\n" if $DEBUG;
        push @$order, $acc_sv;
	# As a further sanity check that the seq can only appear once
	$bio_seq_objs->{$acc_sv} = $bio_seq; # "*************TEST***************";
    }
    close $fh;

    return $order, $bio_seq_objs;
}

#
# Get the chromosome
#---------------------------------------------------------------------------------------------------
# returns a chromosome when given a db object and a chromosome name
sub get_chromosome{
    
    my ($db , $chr_name) = @_;
 
    my $chr_adp = $db->get_ChromosomeAdaptor();
    my $chr;
    eval{  $chr = $chr_adp->fetch_by_chr_name($chr_name) };    
    
    if (! $@) {   # if no errors with getting the chromosome 
        return $chr;
    }
    else{
        ## put a new chromosome into the db to get its id # note that the length value is a default value and will be set later 
        my $chr = Bio::EnsEMBL::Chromosome->new(
                                                -chr_name      => $chr_name,
                                                -adaptor       => $chr_adp,
                                                -length       => 1 
                                                );
           $chr_adp->store($chr);
        return $chr;     
    }
}

#
# update_chromosome_length
#-----------------------------------------------------------------------------------------------------------------------
# updates the chromosome length field 
# after assembly table has had values entered
sub update_chromosome_length{
    
     my ($db, $chromosome) = @_ ;
         
     my $chr_id = $chromosome->dbID;
     
     my $chr_length_query = qq{ SELECT max(chr_end) FROM assembly WHERE chromosome_id = $chr_id } ;   
     my $sth = $db->prepare($chr_length_query);
     if($sth->execute()){
         my $chr_end = $sth->fetchrow ;
         if (!defined $chr_end) {$chr_end = 0}; 
     
         $sth = $db->prepare("UPDATE chromosome SET length = $chr_end WHERE chromosome_id = $chr_id");
         if ($sth->execute){  
         }
         else{
            warn "Couldn't update the chromosome \n";
         } 
     
     }
     else{
         warn "Couldn't find the max_end value for chromosome with ID: $chr_id";
     }   
}
#
# store_input_id_analysis
#-------------------------------------------------------------------------------
# forces a write to the input_id_analysis table
#
sub store_input_id_analysis{
    my ($contigs, $pipe_db, $ana_obj) = @_;
    my $state_info = $pipe_db->get_StateInfoContainer();
    foreach my $contig(@$contigs){
	my $ctg_name = $contig->name();
	eval { $state_info->store_input_id_analysis($ctg_name, $ana_obj, 'localhost'); };
	warn "$ctg_name already has entry for " . $ana_obj->logic_name . " $@ \n" if $@ && $DEBUG;
    }
}
sub useage{ exit(exec('perldoc', $0)); }


