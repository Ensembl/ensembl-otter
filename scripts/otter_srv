#!/usr/local/bin/perl

# Shamelessly ripped off from pfetch_srv
package OtterServer;

use strict;
use IPC::Open2;
use IO::Socket;
use POSIX qw(:signal_h);
#use POSIX qw(:signal_h setsid);
use Sys::Hostname;
use Getopt::Long;
use HTTP::Daemon;
use Bio::EnsEMBL::DBSQL::DBAdaptor;
use OtterDefs;
use Bio::Otter::LogFile;

$| = 1;

#-------------------- main config options --------------------#
my $HOSTNAME              = $OTTER_SERVER;
my $DEFAULT_HOME          = $OTTER_SERVER_ROOT;
my $ALT_HOME              = $OTTER_ALTROOT;
my $SCRIPTDIR             = $OTTER_SCRIPTDIR;
my $HOME                  = $DEFAULT_HOME;
my $SCRIPT_TIMEOUT        = int($OTTER_SCRIPT_TIMEOUT) || 60;
my $PIDFILE               = $DEFAULT_HOME . "/otter_srv.pid";
my $LOGFILE               = $DEFAULT_HOME . "/otter_srv.log";
my $OTTER_INFO            = undef;
my $PREFORK               = 5;
my $MAX_CLIENTS_PER_CHILD = $OTTER_MAX_CLIENTS;
my $SOCKET                = $OTTER_SERVER_PORT;
my $DEBUG                 = 1;
my $VERSION               = "0.1";
my $GET_SCRIPTS           = $OTTER_GET_SCRIPTS  || {};
my $POST_SCRIPTS          = $OTTER_POST_SCRIPTS || {};
$ENV{SCRIPT_NAME}         = 'OTTER_SERVER';
#--------------------- global variables ----------------------#
my %CHILDREN = ();  # keys are current child process IDs
my $CHILDREN = 0;   # current number of children
#-------------------------------------------------------------#



if ($ARGV[0] eq '--alt') {
  $HOME = $ALT_HOME;
}

if ($SOCKET != 19312) {
  $PREFORK               = 3;
  $MAX_CLIENTS_PER_CHILD = 25;
}
#  $MAX_CLIENTS_PER_CHILD = 500;

# establish SERVER socket, bind and listen.

my $server = HTTP::Daemon->new(
  LocalPort => $SOCKET,
  Type      => SOCK_STREAM,
  Proto     => 'tcp',
  Reuse     => 1,
  Listen    => 10
) or die "making socket: $@\n";

make_log_file($LOGFILE);
make_pid_file($PIDFILE);
# Fork off  children.
print "\nCreating Children...\n";
for (1 .. $PREFORK) {
  make_new_child();
}

# Install signal handlers.
$SIG{CHLD} = \&REAPER;
$SIG{INT}  = \&HUNTSMAN;
$SIG{USR1} = \&DEF_HOME;
$SIG{USR2} = \&ALT_HOME;
$SIG{HUP}  = \&ROTATE_LOGS;

# And maintain the population.
while (1) {
  sleep;    # wait for a signal (i.e., child's death)
  for (my $i = $CHILDREN ; $i < $PREFORK ; $i++) {
    make_new_child();    # top up the child pool
  }
}

###############################################################################

sub make_new_child {
  my $pid;
  my $sigset = POSIX::SigSet->new(&POSIX::SIGINT);
  $sigset->addset(&POSIX::SIGHUP);

  my $sigset2 = POSIX::SigSet->new(&POSIX::SIGHUP);

  # block 'INT' signal during fork
  sigprocmask(SIG_BLOCK, $sigset) or die "Can't block SIGINT for fork: $!\n";
  die "fork: $!" unless defined($pid = fork);

  if ($pid) {

###########################################################################################
    # Parent process code executes from here
    # Parent records the child's birth and returns.
###########################################################################################
    sigprocmask(SIG_UNBLOCK, $sigset) or die "Can't unblock SIGINT for fork: $!\n";
    $CHILDREN{$pid} = 1;
    $CHILDREN++;
    print "Child born: $pid (Total children: $CHILDREN)\n" if $DEBUG;
    return;
  } else {

###########################################################################################
    # Child process code executes from here
###########################################################################################

    $SIG{INT} = 'DEFAULT';
    $SIG{HUP} = sub { print STDERR "Received SIGHUP, child $$ resigning\n"; exit; };

    sigprocmask(SIG_UNBLOCK, $sigset) or die "Can't unblock SIGINT for fork: $!\n";

    # $HTTP::Daemon::DEBUG = 1;
    for (my $i = 0 ; $i < $MAX_CLIENTS_PER_CHILD ; $i++) {
      my $client = $server->accept() or last;

      sigprocmask(SIG_BLOCK, $sigset2) or die "Can't block SIGHUP for request: $!\n";
      my $sigset_CHLD = POSIX::SigSet->new(&POSIX::SIGCHLD);
      sigprocmask(SIG_BLOCK, $sigset_CHLD) or die "Can't block SIGCHLD for THIS BIT: $!\n";

      my $r = $client->get_request;

      my $perl5lib  = $ENV{PERL5LIB};
      my $path      = $ENV{PATH};
      my $vegadbsrc = $ENV{VEGADBSRC};

      %ENV = ();
      $ENV{PERL5OPT}  = 'MBio::Otter::LogFile';
      $ENV{PERL5LIB}  = $perl5lib;
      $ENV{PATH}      = $path;
      $ENV{VEGADBSRC} = $vegadbsrc;
      set_cgi_env($r);


      $ENV{REMOTE_ADDR} = $client->peerhost;
      $ENV{REMOTE_PORT} = $client->peerport;
      $ENV{SERVER_ADDR} = $client->sockhost;
      $ENV{SERVER_PORT} = $client->sockport;
      $ENV{AUTHUSERFILE}  = "$OTTER_SERVER_ROOT/.htpasswd" if -e "$OTTER_SERVER_ROOT/.htpasswd";
      $ENV{AUTHGROUPFILE} = "$OTTER_SERVER_ROOT/.htgroups" if -e "$OTTER_SERVER_ROOT/.htgroups";
      
      my $uri = $r->url->path;
      if ($r->method eq 'GET' and $GET_SCRIPTS->{$uri}) {
        my $program = $ENV{SCRIPT_FILENAME} = "$SCRIPTDIR/" . $GET_SCRIPTS->{$uri};
	print STDERR "*************  BEGIN $uri  *************";
        my @args = ();
        if( my $pid = open (my $fh, '-|') ){
            eval{
		# Timeout code
                # local $SIG{ALRM} = sub { warn qq{!TIMEOUT! PID <$pid> is TERMinating...\n};  kill 9, $pid;};
                # alarm ($SCRIPT_TIMEOUT); # defaults to 1 minute
                while (<$fh>){
                    print $client $_;
                }
                close $fh;# || die qq{unexpected exit by $program: $!\n};
                #alarm 0;
            };
            if ($@) {
                print STDERR qq{ERROR: $@ \n};
            }
        }else{
            exec( $program, @args );
            die q{Something went wrong here $!: } . $! . "\n";
        }
            
      } elsif ($r->method eq 'POST' and $POST_SCRIPTS->{$uri}) {
        my $program = $ENV{SCRIPT_FILENAME} = "$SCRIPTDIR/" . $POST_SCRIPTS->{$uri};
        my ($in, $out);
        my $pid = open2($out,$in,$program);
        print $in $r->content;
        close $in;
        open  FPDBG,">../data/test_server_wr.xml";
        print FPDBG $r->content;
        close FPDBG;
        print STDERR "********** Printing response ***********";
        
        while (<$out>) {
          #print STDERR $_;
          print $client $_;
        }
        #print $client $r->content;
        print STDERR "************* End response *************";
        close $out;
        waitpid $pid, 0;
      } else {
        my $message = "Unknown command " . $r->method . " " . $r->url->path . "\n";
        print $client $message;
        print STDERR $message;
      }
      $client->close;
      sigprocmask(SIG_UNBLOCK, $sigset_CHLD) or die "Can't unblock SIGCHLD after request: $!\n";
#      $SIG{CHLD} = \&REAPER;
      sigprocmask(SIG_UNBLOCK, $sigset2) or die "Can't unblock SIGHUP after request: $!\n";
    }

    print STDERR "Child $$: reached max client count - exiting.";
    exit;    ## very, very important exit!
  }
}

1;

sub set_cgi_env {
  my ($r) = @_;
  $r->headers->scan(\&set_http_header_env);
  $r->headers->scan(\&set_http_header_prefix_env);
  $ENV{"GATEWAY_INTERFACE"} = "CGI/1.1";
  $ENV{"QUERY_STRING"}      = $r->url->query;
  $ENV{"REQUEST_URI"}       = $r->uri;
  $ENV{"REQUEST_METHOD"}    = $r->method;
  $ENV{"SCRIPT_NAME"}       = $r->url->path;
  $ENV{"SERVER_ADMIN"}      = "searle\@sanger.ac.uk";
  $ENV{"SERVER_PORT"}       = $SOCKET;
  $ENV{"SERVER_PROTOCOL"}   = "HTTP/1.0";
  $ENV{"SERVER_SOFTWARE"}   = $server->product_tokens;
}

sub set_http_header_env {
  my ($key, $val) = @_;
  $key =~ s/-/_/g;

  $ENV{ uc($key) } = $val;
}

sub set_http_header_prefix_env {
  my ($key, $val) = @_;
  $key =~ s/-/_/g;

  $ENV{ "HTTP_" . uc($key) } = $val;
}

###########################################################
sub make_pid_file {

  my ($pidfile) = @_;

  print STDERR "OTTER_SERVER : Starting up Otter server on $HOSTNAME....\n" if $DEBUG;
  print STDERR "OTTER_SERVER : Using database configured from $HOME\n"      if $DEBUG;
  print STDERR "OTTER_SERVER : PID file at $pidfile\n"                      if $DEBUG;
  open(PID, "> $pidfile") or die "Cannot write to pid file '$pidfile': $!\n";
  print PID "$$\n";
  close(PID);
  print STDERR "OTTER_SERVER : [Parent pid on $HOSTNAME: $$]\n";
  return;
}

###########################################################
sub DEF_HOME {
  $HOME = $DEFAULT_HOME;
  print STDERR "OTTER_SERVER : Swapping to default directory location in $HOME (restarting children)...\n";
  my @kids = keys %CHILDREN;    # get child PIDs

  foreach (@kids) {
    kill 'HUP', $_;    # ...and tell them
    print STDERR "OTTER_SERVER : \tkilled $_\n" if $DEBUG;
    sleep 5;
  }
  print STDERR "OTTER_SERVER : Sent DEF HUP to children: ", join (",", @kids), "\n" if $DEBUG;
  $SIG{USR1} = \&DEF_HOME;
}

###########################################################
sub ALT_HOME {
  $HOME = $ALT_HOME;
  print STDERR "OTTER_SERVER : Swapping to backup directory location in $HOME (restarting children)...\n";
  my @kids = keys %CHILDREN;    # get child PIDs

  foreach (@kids) {
    kill 'HUP', $_;    # ...and tell them
    print STDERR "OTTER_SERVER : \tkilled $_\n" if $DEBUG;
    sleep 5;
  }
  print STDERR "OTTER_SERVER : Sent ALT HUP to children: ", join (",", @kids), "\n" if $DEBUG;
  $SIG{USR2} = \&ALT_HOME;
}

###########################################################
sub REAPER {    # takes care of dead children
  my $sigset = POSIX::SigSet->new(&POSIX::SIGCHLD);
  sigprocmask(SIG_BLOCK, $sigset) or die "Can't block SIGCHLD for reaper: $!\n";
  my $pid = wait;

  if (delete $CHILDREN{$pid}) {
    $CHILDREN--;
  } else {

  #  warn("OTTER_SERVER : Attempted to delete a non-child PID: $pid!\n") if $DEBUG;
  #  warn("OTTER_SERVER : Child PIDs are:\n", join("\n",keys %CHILDREN), "\n") if $DEBUG;
  }
  sigprocmask(SIG_UNBLOCK, $sigset);
  #print STDERR "OTTER_SERVER : Got SIGCHLD from: $pid\n" if $DEBUG;
  $SIG{CHLD} = \&REAPER;
}

###########################################################
sub HUNTSMAN {    # signal handler for SIGINT
  local ($SIG{CHLD}) = 'IGNORE';    # we're going to kill our children
  print "OTTER_SERVER : Killing children...\n" if $DEBUG;
  kill 'INT' => keys %CHILDREN;
  exit;                             # clean up with dignity
}

sub ROTATE_LOGS{
    my $rotate_time = time;
    my $new_logfile = $LOGFILE . "_rotated_at_" . $rotate_time;
    print STDOUT "OTTER_SERVER : Rotating logs...\n" if $DEBUG;
    # sideways move of current log, handles should still point to new one.
    rename $LOGFILE, $new_logfile;
    my @kids = keys %CHILDREN;    # get child PIDs
    foreach (@kids) {
	kill 'HUP', $_;    # ...and tell them
	print STDERR "Killed Child $_" if $DEBUG;
	sleep 5; # good idea ??????
    }
    print STDOUT "OTTER_SERVER : Sent ALT HUP to children: ". join (",", @kids). "\n" if $DEBUG;
    # reopen the log files
    make_log_file($LOGFILE);
    # note to log file reader
    print STDERR "using this log file now as from $rotate_time\n";
    # wake this script up a bit, and make children
    &{$SIG{CHLD}};

    $SIG{HUP} = \&ROTATE_LOGS;
}

##################
# log file stuff, only for STDERR.  Do we need something for STDOUT?
sub make_log_file{
    my $output = shift;
    close STDERR; 
    open (STDERR, ">$output")   or die "Can't dup stdout: $!";
}

###########################################################
sub terminate_client {
  my ($c) = @_;
  $c->close;
}

###########################################################
sub usage {

  return qq{
        
        OTTER SERVER - retrieve and store annotations into a remote otter database

        Usage:        otter_srv [options]

        Options:
        --alt         Start server with alternative home set

        by Steve Searle (searle\@sanger.ac.uk)
        Version $VERSION, August 13 2002

};

}

###########################################################
sub otter_server_status {

  my ($socket) = @_;

  print $socket "\n\n";
  print $socket "        ***********************************************\n";
  print $socket "        ******   OTTER SERVER v$VERSION STATUS   ******\n";
  print $socket "        ***********************************************\n";
  print $socket "\tOtter server host: $HOSTNAME\n";
  print $socket "\tOtter server port: $SOCKET\n";

  # print $socket "\tEnsembl Database: ", $STATE->db(),   "\n";
  # print $socket "\tEnsembl Server: ",   $STATE->host(), "\n";
  print $socket "\tNo. child processes: $PREFORK\n";
  print $socket "\tMax. clients/child: $MAX_CLIENTS_PER_CHILD\n";
  print $socket "\tConfig location:  $HOME\n";
  my $j = 1;

  print $socket "\n\n";

  return ();

}
